import numpy as np
import rasterio
import os
import seaborn as sns
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import geopandas as gpd

################ Variables ################
trange = np.arange(0,5,1)
siteName = "Narrabeen"
epsg = 28356


################ Paths ################

regionHome = "\\Users\\z3531278\Documents\\01_FEWS-RegionHome-Aus"
xbWorkDir = "\\Users\\z3531278\Documents\\01_FEWS-RegionHome-Aus\\Modules\\XBeach\\%s\\runs\\latest\\workDir" % siteName
postProcessDir = os.path.join(xbWorkDir,"postProcess")
gaugesDirLines = os.path.join(postProcessDir,"gauges\\lines")
visualizeDir = os.path.join(postProcessDir,"visualize")
imagery = os.path.join(regionHome,"Data\\imagery\\narrabeen_epsg28356.tif")


# Make directories if they don't exist
if not os.path.exists(visualizeDir):
    os.makedirs(visualizeDir)



################ plotmymap function ################
def plotmymap(axs, gaugefile=None, ewlgdf= None, imagery=None, 
             time=None, epsg=None):

    ########## Get extent of raster image and set ticks ##########
    # Note: if there aren't enough ticks on the ends, \
    # change the lower and upper bounds to either +/- \
    # xint or yint
    """my_image = georaster.SingleBandRaster(imagery)
    xint, yint = 0.5, 0.5
    lowerX = xint*round(my_image.extent[0]/xint)+xint
    upperX = xint*round(my_image.extent[1]/xint)+xint
    xticks = np.arange(lowerX, upperX, xint)
    lowerY = yint*round(my_image.extent[2]/yint)
    upperY = yint*round(my_image.extent[3]/yint)+yint
    yticks = np.arange(lowerY, upperY, yint)"""

    my_image = rasterio.open(imagery)
    print("my_image.bounds: ", my_image.bounds)
    import georaster
    my_image2 = georaster.SingleBandRaster(imagery)
    print("extent for my_image2: ", my_image2.extent)


    # Plot aerial imagery
    # sometimes the reading of the my_image.extent is really inconsistent. Randomly flips the y extents.
    from rasterio.plot import show
    show(my_image.read(),ax=axs, transform=my_image.transform)
    """plt.imshow(my_image.read(1), origin='upper', \
        extent=[my_image.bounds[0],\
        my_image.bounds[2],\
        my_image.bounds[1],\
        my_image.bounds[3]], \
        transform=ccrs.epsg(epsg))"""
    """plims = axs.imshow(my_image.r, origin='upper', \
        extent=[my_image.extent[0],\
        my_image.extent[1],\
        my_image.extent[2],\
        my_image.extent[3]], \
        transform=ccrs.epsg(epsg))"""


    # Load and plot EWL points
    gdf = gpd.read_file(gaugefile)
    gdf.plot(ax = axs, color="blue")
    print(gdf.head())

    # Plot extreme water line
    ewlgdf.plot(ax = axs, color="darkblue")

    # Plot time
    tstepText = "time = %s sec" % str(int(time))
    plt.text(344800., 6270200, tstepText,color='white',
            fontsize=14,fontweight="normal",
            horizontalalignment='right',verticalalignment='top')

    return


################ loop through and generate plots ################

counter = 1
ewlgdf = gpd.read_file(os.path.join(postProcessDir,"ewl_XBeach.shp"))
for file in os.listdir(gaugesDirLines):
    if file.endswith(".shp"):
        # Parse filename
        # Time is in seconds from start time (which includes spin-up time)
        time_s = str(file).split("_")
        time_s = time_s[1].split(".")[0]
        time_s = int(time_s.split("s")[0])
        time_np = np.timedelta64(time_s,"s")
        
        ########### Map parameters ###########
        fig = plt.figure(figsize=(8.75, 10.5),facecolor="white")
        sns.set_style('white')
        # set projection to use
        projex = ccrs.epsg(epsg)
        # tick style
        sns.set_style("ticks", {"xtick.major.size": 8, "ytick.major.size": 8})
        # axis
        ax = fig.add_subplot(1, 1, 1, projection=projex)
        

        ########### Plot map ###########
        plotmymap(ax, gaugefile=os.path.join(gaugesDirLines,file), 
                 ewlgdf= ewlgdf, imagery=imagery, time=time_s, epsg=epsg)


        ########### Save map ###########
        figPath = os.path.join(visualizeDir, '%s_%s.png' % (siteName,str(counter).zfill(5)))
        plt.savefig(figPath,dpi=250,bbox_inches='tight')
        counter += 1