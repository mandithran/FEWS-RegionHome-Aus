import os
import numpy as np
import pandas as pd
import geopandas as gpd
import xarray as xr
from shapely.ops import nearest_points

#============== Read in Auswave mesh point locations ==============#
def loadMeshPts(meshPts=None, epsg=None):

    df = pd.read_csv(meshPts)
    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.lon, df.lat))
    ausWaveEPSG = int(epsg)
    gdf.set_crs(epsg=ausWaveEPSG)

    return gdf

#============== Load Auswave output forecast name  ==============#
def loadAuswave(locSet=None, wavesDir=None, xbModel=None):

    # Parse date to match Auswave output naming convention
    bomDate = str(str(xbModel.startTime.year)+
            str(xbModel.startTime.month).zfill(2)+
            str(xbModel.startTime.day).zfill(2))
    bomTime = str(str(xbModel.startTime.hour).zfill(2)+
            str(xbModel.startTime.minute).zfill(2))
    bomDT = str(bomDate+"T"+bomTime+"Z")
    cityCode = locSet.loc[locSet["Name"]==xbModel.siteName, "City_code"].iloc[0]
    fname = "%s.msh.%s.nc" % (cityCode,bomDT)

    # Read in output
    ausWavedf = os.path.join(wavesDir, fname)
    ds = xr.open_dataset(ausWavedf)

    return ds

def nearGeom(point, pts=None, gdfIn=None, outVar=None):
    # find the nearest point and return the corresponding Place value
    nearest = gdfIn.geometry == nearest_points(point, pts)[1]
    geometries = gdfIn[nearest].geometry.to_numpy()[0]
    indeces = gdfIn[nearest].index.to_numpy()[0]
    if outVar == "index":
        return indeces
    elif outVar == "geometries":
        return geometries
    else:
        raise

def extractAusWavePts(ds=None, meshPts=None, epsg=None):

    # Convert xarray dataset to geodataframe
    dfPts = pd.DataFrame({"Lon":ds.longitude.values,
                        "Lat":ds.latitude.values})
    gdfPts = gpd.GeoDataFrame(dfPts, geometry=gpd.points_from_xy(dfPts.Lon,dfPts.Lat))
    gdfPts.set_crs(epsg=int(epsg))

    # unary union of the geomtries 
    pts = gdfPts.geometry.unary_union
    # Find the nearest geometries in Auswave output to "points of interest"
    # Return the old Auswave index value for slicing Auswave output

    meshPts["oldIndex"] = meshPts.apply(lambda row: nearGeom(row.geometry, 
                                                            pts=pts, 
                                                            gdfIn=gdfPts, 
                                                            outVar="index"), 
                                                            axis=1)
    indArr = meshPts["oldIndex"].to_numpy()
    ds = ds.isel(node=indArr)

    return ds

def getTimeStep(ds=None):

    #============== Get timestep of timeseries in seconds ==============#
    t2 = ds.coords["time"][1].values
    t1 = ds.coords["time"][0].values
    dt = t2-t1
    dt = dt.astype('timedelta64[s]').astype(int).astype(float)

    return dt

def generateWaveFiles(ds=None, xbModel=None,
                      jonSwapParam=3.3,dirSpread=10.,
                      dtbc=1.):

    dt = getTimeStep(ds=ds)
    
    # Round to 3 decimal places
    roundDec = 3
    for index in np.arange(0,ds.sizes['node']):
        dfOut = pd.DataFrame({"Hsig":ds.hs[:,0].values.round(roundDec),
                             "Tp":ds.tp[:,0].values.round(roundDec),
                             "dir":ds.dir[:,0].values.round(roundDec),
                             "JS":jonSwapParam,
                             "dirSpread":dirSpread,
                             "dt_sec":dt.round(roundDec),
                             "dtbc":dtbc})
        ofileName = "wavefile%s.txt" % (index+1)
        dfOut.to_csv(os.path.join(xbModel.modelWorkDir,ofileName), 
                    sep='\t', header=False, index=False)


def moveWavestoBoundary(ncPath=None, meshPts=None, 
                        epsg=None, xbModel=None):

    # Load XBeach mesh as geodataframe - netCDF format
    # This netCDF file should have ncols, nrows, epsg metadata
    xbds = xr.open_dataset(ncPath)
    ncolXB = xbds.ncols
    nrowXB = xbds.nrows

    # Convert to geodataframe to do point searching
    xbgdf = xbds.to_dataframe()
    xbgdf = gpd.GeoDataFrame(xbgdf, geometry=gpd.points_from_xy(xbgdf.globalx,xbgdf.globaly))
    xbEPSG = int(xbds.epsg)
    xbgdf.set_crs(xbEPSG)

    # Using points of interest (now in ds), find closest points on XBeach mesh,
    # return value of index in XBeach output
    # Reproject points to projection used in XBeach
    gdf_proj = meshPts.copy()
    gdf_proj.set_crs(epsg=epsg, inplace=True)
    gdf_proj['geometry'] = gdf_proj['geometry'].to_crs(epsg=xbEPSG)
    # unary union of the geomtries 
    pts = xbgdf.geometry.unary_union
    gdf_proj["xbIndex"] = gdf_proj.apply(lambda row: 
                     nearGeom(row.geometry, pts=pts, gdfIn=xbgdf, outVar="index"), axis=1)

    # Grab the index in the relevant row, first column
    # Column indeces go up starting from seaward points
    # Split xbeach indeces into separate rows, cols
    indList = gdf_proj.xbIndex.tolist()
    gdf_proj[["xbcol","xbrow"]] = pd.DataFrame(indList, index=gdf_proj.index)
    gdf_proj['targetCol'] = 0 # First column, starting from seaward boundary
    gdf_proj['targetRow'] = gdf_proj.xbrow

    # Grab relevant geometries from XBeach grid using target indeces
    # Slice by desired cols first
    #gdf_proj['targetX'] = xbgdf.loc[0]
    targetColArr = gdf_proj['targetCol'].values
    targetRowArr = gdf_proj['targetRow'].values
    targetInd = zip(targetColArr,targetRowArr)
    xbgdf_subset = xbgdf.loc[targetInd]
    xbgdf_subset['xtarget'] = xbgdf_subset.geometry.x
    xbgdf_subset['ytarget'] = xbgdf_subset.geometry.y
    # Round vals
    xbgdf_subset = xbgdf_subset.round({'xtarget':2,'ytarget':2})
    # Bring old index over for merging
    xbgdf_subset['ind'] = gdf_proj['ind'].values

    # Merge dfs
    df = pd.merge(gdf_proj,xbgdf_subset,on="ind")
    print(df)

    # Round and convert coordinates to ints
    df['xtarget'] = df['xtarget'].round(decimals=0).astype(int)
    df['ytarget'] = df['ytarget'].round(decimals=0).astype(int)

    return df, ncolXB, nrowXB