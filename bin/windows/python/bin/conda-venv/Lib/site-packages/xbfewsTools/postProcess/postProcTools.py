from shapely.ops import nearest_points
from shapely.geometry import box
import geopandas as gpd
import numpy as np
from rasterio.mask import mask
from scipy.interpolate import griddata
from shapely.geometry import Polygon, shape 
import pandas as pd
import rasterio
from rasterio.transform import Affine
from pyproj import CRS

def nearGeom(point, pts=None, gdfIn=None, outVar=None):
    # find the nearest point and return the corresponding Place value
    nearest = gdfIn.geometry == nearest_points(point, pts)[1]
    geometries = gdfIn[nearest].geometry.to_numpy()[0]
    indeces = gdfIn[nearest].index.to_numpy()[0]
    if outVar == "index":
        return indeces
    elif outVar == "geometries":
        return geometries
    else:
        raise

def search_string_in_file(file_name, string_to_search):
    """Search for the given string in file and return lines containing that string,
    along with line numbers"""
    line_number = 0
    list_of_results = []
    # Open the file in read only mode
    with open(file_name, 'r') as read_obj:
        # Read all lines in the file one by one
        for line in read_obj:
            # For each line, check if line contains the string
            if string_to_search in line:
                # If yes, then add the line number & line as a tuple in the list
                list_of_results.append((line_number, line.rstrip()))
            line_number += 1
    # Return list of tuples containing line numbers and lines where string is found
    return list_of_results

def search_by_line_num(file_name, lineIndex):
    with open(file_name) as fp:
        for i, line in enumerate(fp):
            if i == lineIndex:
                dummyPt = line
    return dummyPt


def clipShp(shp=None,mask=None):
    bounds = mask.bounds
    geom = box(*bounds)
    dfr = gpd.GeoDataFrame({"id":1,"geometry":[geom]})
    dfr = dfr.set_crs(mask.crs)
    gdf_clipped = gpd.clip(shp, dfr)
    return gdf_clipped

def interpXBmesh(ds=None):
    """
    For interpolation steps using xarray see: http://xarray.pydata.org/en/stable/interpolation.html
    Accepts an xarray dataset
    """
    # Create data array for resampling
    # Extract dimensions - based on minx, miny, maxx, maxy
    minx = min(ds.globalx.values.flatten())
    miny = min(ds.globaly.values.flatten())
    maxx = max(ds.globalx.values.flatten())
    maxy = max(ds.globaly.values.flatten())

    # Set resolution based on cross-shore resolution of landward-most points
    # Theoretically should be smallest resolution in the irregular grid
    # Take first row and subtract last x value from second to last
    reso = np.absolute(ds.globalx.values[0][-1]-ds.globalx.values[0][-2])
    reso = 2*round(reso/2.) + 2 # round resolution up to the nearest 2 m (just to have a nice number)

    # Create the regular grid
    xx = np.arange(minx,maxx,reso)
    yy = np.arange(miny,maxy,reso)

    # Run interpolation (check link above)
    zi = griddata((ds.globalx.values.flatten(),ds.globaly.values.flatten()),
             ds.zb.values.flatten(), (xx[None,:], yy[:,None]), method="cubic")

    # Reshape interpolated array
    zi = np.reshape(zi,(len(yy),(len(xx))))

    # Returns 1d x and y arrays, and 2d interpolated mesh
    return xx,yy,reso,zi

def generateXBmask(ds=None, epsg=None):
    # Extract points at seaward boundary
    xBound = ds.globalx[:,0].values.flatten()
    yBound = ds.globaly[:,0].values.flatten()
    # Append lower bound
    xBound = np.append(xBound,ds.globalx[-1,:].values.flatten())
    yBound = np.append(yBound,ds.globaly[-1,:].values.flatten())
    # Append landward bound
    xBound = np.append(xBound,np.flip(ds.globalx[:,-1].values.flatten()))
    yBound = np.append(yBound,np.flip(ds.globaly[:,-1].values.flatten()))
    # Append upper bound
    xBound = np.append(xBound,np.flip(ds.globalx[0,:].values.flatten()))
    yBound = np.append(yBound,np.flip(ds.globaly[0,:].values.flatten()))

    # Convert to geo series
    df = pd.DataFrame(data=xBound,columns=["x"])
    df["y"] = yBound

    # Make mask of curvilinear coordinate bounds
    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.x, df.y))
    gdf.set_crs(epsg=epsg)
    gs = gpd.GeoSeries(Polygon(gdf.geometry.tolist()),crs=epsg)

    # This line exports the mask in shapefile format
    #gs.to_file(os.path.join(postProcessDir,"test.shp"))

    return gs

def numpy2gtiff(arr=None, epsg=None, x1d=None, y1d=None,
                reso=None,filepath=None):
    """Do not generate the transformation this way!!
    It weirdly rotates the raster!
    transform = rasterio.transform.from_bounds(minx,miny,
                                           maxx,maxy,
                                           len(xx),len(yy))"""
    # Define coordinate system
    cc = CRS.from_epsg(epsg)

    # Generate the mesh from 1d arrays
    gridX,gridY = np.meshgrid(x1d,y1d)
    transform = Affine.translation(gridX[0][0]-reso/2, 
                                gridY[0][0]-reso/2)*Affine.scale(reso,reso)

    # Write out new dataset to Geotiff
    new_dataset = rasterio.open(filepath, 
                            'w', driver='GTiff',
                            height = len(y1d), width = len(x1d),
                            count=1, dtype=arr.dtype,
                            crs=cc,
                            transform=transform)

    new_dataset.write(arr,1)
    new_dataset.close()
    
def maskXBoutput(inRaster=None,shp=None,outRaster=None):
    with rasterio.open(inRaster) as src:
        out_image, out_transform = mask(src, shp, nodata=-9999,crop=True)
        out_meta = src.meta

    out_meta.update({"driver": "GTiff",
                    "height": out_image.shape[1],
                    "width": out_image.shape[2],
                    "transform": out_transform})

    with rasterio.open(outRaster, 
                    "w", **out_meta) as dest:
        dest.write(out_image)

def XB2csv(x1d=None,y1d=None,arr2d=None,outPath=None):
    # Converts x and y 1D arrays to 2D arrays and then back to a flattened 1D array
    # For xyz/csv format 
    ncols = len(x1d)
    nrows = len(y1d)
    xarr = np.tile(x1d,nrows).reshape(nrows,ncols).flatten()
    yarr = np.repeat(y1d,ncols).reshape(nrows,ncols).flatten()
    df = pd.DataFrame(xarr,columns=['x'])
    df['y'] = yarr.flatten()
    df['z'] = arr2d.flatten()
    df.to_csv(outPath)