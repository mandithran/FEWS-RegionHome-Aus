#################### Modules ####################
import xarray as xr
import os
import numpy as np
from scipy.interpolate import griddata
import rasterio
import rioxarray as rio
from pyproj import CRS
import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon, shape 


##################### Variables ####################
siteName = "Narrabeen"
vars2process = ["zb"]
#attributes = {"zb": "bed level"}
epsg = int(28356)


#################### Paths ####################
regionHome = "C:\\Users\\z3531278\\Documents\\01_FEWS-RegionHome-Aus"
xbWorkDir = os.path.join(regionHome,"Modules\\XBeach\\%s\\runs\\latest\\workDir" % siteName)
postProcessDir = os.path.join(xbWorkDir,"postProcess")
gridsDir = os.path.join(postProcessDir,"grids")
xboutput = os.path.join(xbWorkDir,"xboutput.nc")



#################### Create paths if they don't exist ####################
if not os.path.exists(postProcessDir):
    os.makedirs(postProcessDir)
for v in vars2process:
    opath = os.path.join(gridsDir,v)
    if not os.path.exists(opath):
        os.makedirs(opath)
    

#################### Load dataset ####################
ds = xr.open_dataset(xboutput)
# TODO: remove these two lines
ds = ds.isel({"globaltime":0})
ds = ds[["zb"]]

#print(ds.keys)

#################### Interpolate irregular mesh onto regular mesh ####################
# For interpolation steps using xarray see: http://xarray.pydata.org/en/stable/interpolation.html
# "Advanced interpolation"

# Create data array for resampling
# Extract dimensions - based on minx, miny, maxx, maxy
minx = min(ds.globalx.values.flatten())
miny = min(ds.globaly.values.flatten())
maxx = max(ds.globalx.values.flatten())
maxy = max(ds.globaly.values.flatten())

# Set resolution based on cross-shore resolution of landward-most points
# Theoretically should be smallest resolution in the irregular grid
# Take first row and subtract last x value from second to last
#print(ds.globalx.values[0])
reso = np.absolute(ds.globalx.values[0][-1]-ds.globalx.values[0][-2])
reso = reso/2 # half the resolution just to make it quite fine
reso = 5*round(reso/5) # round resolution to the nearest 5 m (just to have a nice number)
#print(reso)
# Create the regular grid
xx = np.arange(minx,maxx,reso)
yy = np.arange(miny,maxy,reso)

# Create an additional mask to mask interpolation artefacts with "nans"
# Extract points at seaward boundary
xBound = ds.globalx[:,0].values.flatten()
yBound = ds.globaly[:,0].values.flatten()
# Append lower bound
xBound = np.append(xBound,ds.globalx[-1,:].values.flatten())
yBound = np.append(yBound,ds.globaly[-1,:].values.flatten())
# Append landward bound
xBound = np.append(xBound,np.flip(ds.globalx[:,-1].values.flatten()))
yBound = np.append(yBound,np.flip(ds.globaly[:,-1].values.flatten()))
# Append upper bound
xBound = np.append(xBound,np.flip(ds.globalx[0,:].values.flatten()))
yBound = np.append(yBound,np.flip(ds.globaly[0,:].values.flatten()))

df = pd.DataFrame(data=xBound,columns=["x"])
df["y"] = yBound

# Make mask of curvilinear coordinate bounds
gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.x, df.y))
gdf.set_crs(epsg=epsg)
gs = gpd.GeoSeries(Polygon(gdf.geometry.tolist()),crs=epsg)
gs.to_file(os.path.join(postProcessDir,"test.shp"))

#Arguments: rasterio.transform.from_bounds(west, south, east, north, width, height)
transform = rasterio.transform.from_bounds(minx,miny,
                                           maxx,maxy,
                                           len(xx),len(yy))


#print(transform)

# Generate mask array


# Run interpolation (check link above)
zi = griddata((ds.globalx.values.flatten(),ds.globaly.values.flatten()),
             ds.zb.values.flatten(), (xx[None,:], yy[:,None]), method="cubic")

# Rows, columns
zi = np.reshape(zi,(len(yy),(len(xx))))
#zi = np.reshape(zi,(len(xx),(len(yy))))

print("len xx: ", len(xx))
print(type(zi))
print(zi.shape)

# Convert to data arrays
"""da = xr.DataArray(data=zi,dims=["x","y"]),
                  coords=dict(x=(["x"], xx),
                              y=(["y"], yy)),
                  attrs=dict(description="bed level",
                             units="m")
                             )"""

da = xr.DataArray(data=zi,dims=["x","y"])

print("length of x values")
print(len(da.x.values))

# Set CRS of data array
cc = CRS.from_epsg(epsg)
da.rio.write_crs(cc.to_string(), inplace=True)

"""# Reproject to WGS84
print("current projection: %s" % da.rio.crs)
dest_crs = CRS.from_epsg(4326)
da_wgs84 = da.rio.reproject(dst_crs=dest_crs)
print("current projection: %s" % da_wgs84.rio.crs)"""

# create polygon mask
mask = rasterio.features.geometry_mask(
            gs.geometry,
            out_shape=(len(yy),len(xx)),
            transform=transform,
            all_touched=True,
            invert=False)

print(gs.geometry)

mask = xr.DataArray(mask, dims=("x", "y"))
mask.to_netcdf(os.path.join(postProcessDir,"mask.nc"))

print(mask.shape,zi.shape)

print(max(mask["x"].values.flatten()),minx)

#342337.5

######################## New approach ######################## 
# Turn data array into a rasterio object


# get pixel coordinates of the geometry's bounding box


# Mask data array
# mask ds with rasterized gdf
da = da.where(~mask)

# Export to netCDF
da.to_netcdf(os.path.join(postProcessDir,"test.nc"))