import os, re
import numpy as np
import pandas as pd
import geopandas as gpd
import pytz
import xarray as xr
from datetime import datetime, timedelta

#============== Generate time series - GMT ==============#
def generateTimeSeries(forecast=None):

    """
    Generates a time series based on attributes of a
    forecast object. Forecast objects typically set in 
    initializeForecast.py or initializeHotspot.py

    Returns a dataframe
    """

    # Convert inputs to numpy timedelta64 objects
    deltat = np.timedelta64(forecast.deltat) # timestep for water level time series
    startTime = np.datetime64(forecast.startTime) # start time of forecast
    endTime = np.datetime64(forecast.endTime) # end time of forecast

    # Generate time series with numpy 
    timeSeries = np.arange(startTime,endTime+deltat,deltat)

    # Convert to dataframe
    dfts = pd.DataFrame(timeSeries,columns=["time_gmt"])
    # Set times as indeces
    dfts.index = dfts['time_gmt']
    dfts.index = pd.to_datetime(dfts.index, utc=True)
    dfts = dfts.drop(columns=['time_gmt'])

    return dfts

def loadTideData(ifile=None, forecast=None):

    #============== Load tide data - MUST BE IN GMT ==============#
    dft = pd.read_csv(ifile, names=['datetime_gmt','tide_m'], header=0)
    dft['datetime_gmt'] = pd.to_datetime(dft['datetime_gmt'], format="%d-%m-%Y %H:%M", utc=True)
    dft.index=dft['datetime_gmt']
    dft = dft.drop(columns=['datetime_gmt'])
    # Slice and dice the df
    dft = dft[(dft.index >= forecast.startTime) & (dft.index <= forecast.endTime)]

    return dft

#============== Interpolate tidal forecast at 10 m intervals ==============#
def interpSeries(series=None, forecast=None):
    """Series is a dataframe"""
    # Convert timedelta object to a string in minutes
    deltat_min = int(round((forecast.deltat.seconds/60),0))
    upsampled = series.resample('%sT' % deltat_min, origin=forecast.startTime).asfreq()
    interpolated = upsampled.interpolate(method='linear')

    return interpolated


#============== Load surge data - MUST BE IN GMT ==============#
    # Parse rounded system time for filename

def loadSurgeData(surgePath=None, forecast=None):

    dfs = pd.read_csv(surgePath, names=['datetime_gmt','surge_m'], header=0)
    dfs['datetime_gmt'] = pd.to_datetime(dfs['datetime_gmt'], format="%Y-%m-%d %H:%M:%S")
    dfs.index=dfs['datetime_gmt']
    dfs = dfs.drop(columns=['datetime_gmt'])
    dfs = dfs.tz_localize(pytz.utc)
    dfs = dfs[(dfs.index >= forecast.startTime) & (dfs.index <= forecast.endTime)]

    return dfs


#============== Process surge data ==============#
def processNSS_nc(forecast=None, nssDir=None, fname=None):
        
    # =================== Paths =================== #
    ifile = os.path.join(nssDir,fname)

    # Load dataset
    ds = xr.open_dataset(ifile)

    # Take a look at existing coordinates, dimensions, and variables
    # if verbose mode is specified
    #print("NetCDF file metadata:")
    #print(ds.keys)

    # ds.keys will reveal that the NetCDF file does not have lat/lon dimensions - it has a "point" and "time" dimensions
    # These "point" dimensions are essentially the index of a given point
    # The "point dimension" has the same shape as the lat and lon fields
    # This is because this is not a regular grid; each point has a lat, lon value
    # The following will return the index that matches the lat/lon point of interest
    # This index allows for selection of subsets of the xarray
    df = pd.DataFrame({"lon":ds.coords['lon'].values,"lat":ds.coords['lat'].values})
    ind = df[(df['lon']==forecast.lonSurge) & 
            (df['lat']==forecast.latSurge)].index

    # Select surge timeseries for the point of interest
    surge = ds.surge[ind].values

    # Create new pandas df
    dfOut = pd.DataFrame({"Datetime_gmt":ds.coords['time'].values,
                    "surge (m)":surge[0]
                    })

    # Add 12-hour spin-up timeseries that retains the first value
    # of the surge forecast
    dt_delta = dfOut.Datetime_gmt[1]-dfOut.Datetime_gmt[0]
    surgeStartTime = dfOut.Datetime_gmt[0]
    surgeEndTime = dfOut.Datetime_gmt.iloc[-1]
    spinUpTime = forecast.spinUpWindow # argument in hours
    spinUpEndTime = surgeStartTime
    spinUpStartTime = spinUpEndTime-(spinUpTime)
    spinUp_series = pd.date_range(start=spinUpStartTime,
                            end=spinUpEndTime,
                            freq=dt_delta)
    spinUp_df = pd.DataFrame({"Datetime_gmt":spinUp_series,
                            "surge (m)":dfOut["surge (m)"][0]
                            }).set_index("Datetime_gmt")

    # Concatenate spin-up timeseries with real timeseries
    dfOut = dfOut.set_index("Datetime_gmt")
    dfOut = pd.concat([spinUp_df,dfOut])

    # Set timezone info
    dfOut = dfOut.tz_localize(pytz.utc)

    # If the forecast horizon is greater than 3 days, 
    # add an additional extension of the timeseries that sets the surge signal to
    # 0 m for the remainder of the forecast window
    if forecast.forecastHorizon > timedelta(days=int(3)):
        extendedTSStartTime = dfOut.index[-1] + dt_delta
        # Example: if you want a 7-day forecast, you have 
        # four days where the surge forecast needs to be
        # extended (forecast.forecastHorizon - (surgeEndTime-surgeStartTime))
        extensionDuration = forecast.forecastHorizon - (surgeEndTime-surgeStartTime)
        extendedTSEndTime = dfOut.index[-1] + extensionDuration
        extendedSeries = pd.date_range(start=extendedTSStartTime,
                            end=extendedTSEndTime,
                            freq=dt_delta)
        extended_df = pd.DataFrame({"Datetime_gmt":extendedSeries,
                            "surge (m)":0
                            }).set_index("Datetime_gmt")
        # Concatenate this to the water level series df
        dfOut = pd.concat([dfOut,extended_df])

    # File name based on site and date time given in original nc file
    #dateTime = re.split("[_.]", fname)[3]
    #ofname = "nss_%s_%s.csv" % (forecast.siteName, dateTime)
    #ofPath = os.path.join(importDir,ofname)
    #dfOut.to_csv(ofPath)

    return dfOut


#============== Extract surge data ==============#
def extractNSS(forecast=None, ds=None, nss_lat=None, nss_lon=None):

    """
    Extracts the surge forecast from the NSS output from the BoM.
    The point you want to extract needs to be precisely known
    (see nearGeom function in preProcWaves - this can provide
    the precise nearest point on the mesh).

    Inputs:
    forecast: FEWS forecast object, can be a hotspot or regional
      forecast. Defined in initializeRegional.py, initializeHotpsot.py,
      class structure is provided in fewsForecast.py
    ds: xarray dataset containing the netCDF storm surge output.
    nss_lat: latitude of the point of interest where NSS surge forecast
      will be extracted from.
    nss_lon: ditto but for the longitude of the point
    """

    # Select dataset by point of interest
    ds = ds[['surge']]
    ds = ds.where(ds.lat==nss_lat, drop=True)
    ds = ds.where(ds.lon==nss_lon, drop=True)
    
    # Select surge timeseries for the point of interest
    surge = ds.surge.values[0]

    # Create new pandas df
    dfOut = pd.DataFrame({"Datetime_gmt":ds.coords['time'].values,
                    "surge (m)":surge
                    })

    # Time parameters
    dt_delta = dfOut.Datetime_gmt[1]-dfOut.Datetime_gmt[0]
    surgeStartTime = dfOut.Datetime_gmt[0]
    surgeEndTime = dfOut.Datetime_gmt.iloc[-1]

    # Set timezone info
    dfOut = dfOut.set_index("Datetime_gmt")
    dfOut = dfOut.tz_localize(pytz.utc)


    # If the forecast horizon is greater than 3 days, 
    # add an additional extension of the timeseries that sets the surge signal to
    # 0 m for the remainder of the forecast window
    if forecast.forecastHorizon > timedelta(days=int(3)):
        extendedTSStartTime = dfOut.index[-1] + dt_delta
        # Example: if you want a 7-day forecast, you have 
        # four days where the surge forecast needs to be
        # extended (forecast.forecastHorizon - (surgeEndTime-surgeStartTime))
        extensionDuration = forecast.forecastHorizon - (surgeEndTime-surgeStartTime)
        extendedTSEndTime = dfOut.index[-1] + extensionDuration
        extendedSeries = pd.date_range(start=extendedTSStartTime,
                            end=extendedTSEndTime,
                            freq=dt_delta)
        extended_df = pd.DataFrame({"Datetime_gmt":extendedSeries,
                            "surge (m)":0
                            }).set_index("Datetime_gmt")
        # Concatenate this to the water level series df
        dfOut = pd.concat([dfOut,extended_df])


    return dfOut